{
  "id": 5,
  "title": "Multithreading và Concurrency trong Java",
  "content": "# Multithreading và Concurrency trong Java\n\n## Giới thiệu về Multithreading\n\nMultithreading là khả năng thực hiện nhiều thread (luồng) đồng thời trong một chương trình Java. Điều này giúp tăng hiệu suất và khả năng phản hồi của ứng dụng.\n\n### Tại sao cần Multithreading?\n\n1. **Tăng hiệu suất**: Sử dụng nhiều CPU core\n2. **Responsiveness**: UI không bị đơ khi xử lý tác vụ nặng\n3. **Parallel processing**: Xử lý song song nhiều tác vụ\n4. **Resource utilization**: Tận dụng tài nguyên hệ thống\n5. **Scalability**: Ứng dụng có thể mở rộng\n\n### Thread vs Process:\n\n- **Process**: Chương trình độc lập, có memory riêng\n- **Thread**: Luồng thực thi trong process, chia sẻ memory\n\n## Tạo Thread\n\n### Cách 1: Extends Thread Class\n\n```java\npublic class ThreadExample extends Thread {\n    private String threadName;\n    \n    public ThreadExample(String name) {\n        this.threadName = name;\n    }\n    \n    @Override\n    public void run() {\n        for (int i = 1; i <= 5; i++) {\n            System.out.println(threadName + \" - Count: \" + i);\n            try {\n                Thread.sleep(1000); // Sleep 1 giây\n            } catch (InterruptedException e) {\n                System.out.println(threadName + \" bị interrupt\");\n                break;\n            }\n        }\n        System.out.println(threadName + \" hoàn thành\");\n    }\n    \n    public static void main(String[] args) {\n        ThreadExample thread1 = new ThreadExample(\"Thread-1\");\n        ThreadExample thread2 = new ThreadExample(\"Thread-2\");\n        \n        // Bắt đầu thread\n        thread1.start();\n        thread2.start();\n        \n        // Main thread tiếp tục chạy\n        System.out.println(\"Main thread đang chạy...\");\n    }\n}\n```\n\n### Cách 2: Implements Runnable Interface\n\n```java\npublic class RunnableExample implements Runnable {\n    private String threadName;\n    \n    public RunnableExample(String name) {\n        this.threadName = name;\n    }\n    \n    @Override\n    public void run() {\n        for (int i = 1; i <= 5; i++) {\n            System.out.println(threadName + \" - Count: \" + i);\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                System.out.println(threadName + \" bị interrupt\");\n                break;\n            }\n        }\n        System.out.println(threadName + \" hoàn thành\");\n    }\n    \n    public static void main(String[] args) {\n        RunnableExample runnable1 = new RunnableExample(\"Runnable-1\");\n        RunnableExample runnable2 = new RunnableExample(\"Runnable-2\");\n        \n        // Tạo Thread từ Runnable\n        Thread thread1 = new Thread(runnable1);\n        Thread thread2 = new Thread(runnable2);\n        \n        thread1.start();\n        thread2.start();\n        \n        System.out.println(\"Main thread đang chạy...\");\n    }\n}\n```\n\n### Cách 3: Lambda Expression (Java 8+)\n\n```java\npublic class LambdaThreadExample {\n    public static void main(String[] args) {\n        // Tạo thread với lambda\n        Thread thread1 = new Thread(() -> {\n            for (int i = 1; i <= 5; i++) {\n                System.out.println(\"Lambda Thread - Count: \" + i);\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    System.out.println(\"Thread bị interrupt\");\n                    break;\n                }\n            }\n        });\n        \n        thread1.start();\n        \n        // Hoặc sử dụng method reference\n        Thread thread2 = new Thread(LambdaThreadExample::doWork);\n        thread2.start();\n    }\n    \n    public static void doWork() {\n        for (int i = 1; i <= 5; i++) {\n            System.out.println(\"Method Reference Thread - Count: \" + i);\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                System.out.println(\"Thread bị interrupt\");\n                break;\n            }\n        }\n    }\n}\n```\n\n## Thread Lifecycle\n\n### Các trạng thái của Thread\n\n```java\npublic class ThreadLifecycleExample {\n    public static void main(String[] args) {\n        Thread thread = new Thread(() -> {\n            System.out.println(\"Thread đang chạy...\");\n            try {\n                Thread.sleep(2000);\n            } catch (InterruptedException e) {\n                System.out.println(\"Thread bị interrupt\");\n            }\n            System.out.println(\"Thread hoàn thành\");\n        });\n        \n        // NEW - Thread được tạo nhưng chưa start\n        System.out.println(\"Trạng thái: \" + thread.getState()); // NEW\n        \n        thread.start();\n        \n        // RUNNABLE - Thread đang chạy hoặc sẵn sàng chạy\n        System.out.println(\"Trạng thái: \" + thread.getState()); // RUNNABLE\n        \n        try {\n            // Đợi thread hoàn thành\n            thread.join();\n            \n            // TERMINATED - Thread đã hoàn thành\n            System.out.println(\"Trạng thái: \" + thread.getState()); // TERMINATED\n            \n        } catch (InterruptedException e) {\n            System.out.println(\"Main thread bị interrupt\");\n        }\n    }\n}\n```\n\n## Synchronization\n\n### Race Condition Problem\n\n```java\npublic class RaceConditionExample {\n    private static int counter = 0;\n    \n    public static void main(String[] args) throws InterruptedException {\n        Thread thread1 = new Thread(() -> {\n            for (int i = 0; i < 1000; i++) {\n                counter++; // Không thread-safe\n            }\n        });\n        \n        Thread thread2 = new Thread(() -> {\n            for (int i = 0; i < 1000; i++) {\n                counter++; // Không thread-safe\n            }\n        });\n        \n        thread1.start();\n        thread2.start();\n        \n        thread1.join();\n        thread2.join();\n        \n        // Kết quả có thể không phải 2000 do race condition\n        System.out.println(\"Counter value: \" + counter);\n    }\n}\n```\n\n### Synchronized Method\n\n```java\npublic class SynchronizedMethodExample {\n    private static int counter = 0;\n    \n    // Synchronized method\n    public static synchronized void increment() {\n        counter++;\n    }\n    \n    public static void main(String[] args) throws InterruptedException {\n        Thread thread1 = new Thread(() -> {\n            for (int i = 0; i < 1000; i++) {\n                increment(); // Thread-safe\n            }\n        });\n        \n        Thread thread2 = new Thread(() -> {\n            for (int i = 0; i < 1000; i++) {\n                increment(); // Thread-safe\n            }\n        });\n        \n        thread1.start();\n        thread2.start();\n        \n        thread1.join();\n        thread2.join();\n        \n        // Kết quả luôn là 2000\n        System.out.println(\"Counter value: \" + counter);\n    }\n}\n```\n\n### Synchronized Block\n\n```java\npublic class SynchronizedBlockExample {\n    private static int counter = 0;\n    private static final Object lock = new Object();\n    \n    public static void main(String[] args) throws InterruptedException {\n        Thread thread1 = new Thread(() -> {\n            for (int i = 0; i < 1000; i++) {\n                synchronized (lock) {\n                    counter++; // Thread-safe với synchronized block\n                }\n            }\n        });\n        \n        Thread thread2 = new Thread(() -> {\n            for (int i = 0; i < 1000; i++) {\n                synchronized (lock) {\n                    counter++; // Thread-safe với synchronized block\n                }\n            }\n        });\n        \n        thread1.start();\n        thread2.start();\n        \n        thread1.join();\n        thread2.join();\n        \n        System.out.println(\"Counter value: \" + counter);\n    }\n}\n```\n\n## Thread Communication\n\n### Wait và Notify\n\n```java\npublic class ProducerConsumerExample {\n    private static final Object lock = new Object();\n    private static boolean hasData = false;\n    private static String data = null;\n    \n    public static void main(String[] args) {\n        // Producer thread\n        Thread producer = new Thread(() -> {\n            for (int i = 1; i <= 5; i++) {\n                synchronized (lock) {\n                    // Đợi consumer xử lý dữ liệu trước\n                    while (hasData) {\n                        try {\n                            lock.wait();\n                        } catch (InterruptedException e) {\n                            System.out.println(\"Producer bị interrupt\");\n                            return;\n                        }\n                    }\n                    \n                    // Tạo dữ liệu mới\n                    data = \"Data \" + i;\n                    hasData = true;\n                    System.out.println(\"Producer tạo: \" + data);\n                    \n                    // Thông báo cho consumer\n                    lock.notify();\n                }\n                \n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    break;\n                }\n            }\n        });\n        \n        // Consumer thread\n        Thread consumer = new Thread(() -> {\n            for (int i = 1; i <= 5; i++) {\n                synchronized (lock) {\n                    // Đợi producer tạo dữ liệu\n                    while (!hasData) {\n                        try {\n                            lock.wait();\n                        } catch (InterruptedException e) {\n                            System.out.println(\"Consumer bị interrupt\");\n                            return;\n                        }\n                    }\n                    \n                    // Xử lý dữ liệu\n                    System.out.println(\"Consumer xử lý: \" + data);\n                    hasData = false;\n                    data = null;\n                    \n                    // Thông báo cho producer\n                    lock.notify();\n                }\n                \n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    break;\n                }\n            }\n        });\n        \n        producer.start();\n        consumer.start();\n    }\n}\n```\n\n## Executor Framework\n\n### ThreadPool\n\n```java\nimport java.util.concurrent.*;\n\npublic class ThreadPoolExample {\n    public static void main(String[] args) {\n        // Tạo thread pool với 3 threads\n        ExecutorService executor = Executors.newFixedThreadPool(3);\n        \n        // Submit tasks\n        for (int i = 1; i <= 10; i++) {\n            final int taskId = i;\n            executor.submit(() -> {\n                System.out.println(\"Task \" + taskId + \" đang chạy trên \" + \n                    Thread.currentThread().getName());\n                try {\n                    Thread.sleep(2000);\n                } catch (InterruptedException e) {\n                    System.out.println(\"Task \" + taskId + \" bị interrupt\");\n                }\n                System.out.println(\"Task \" + taskId + \" hoàn thành\");\n            });\n        }\n        \n        // Shutdown executor\n        executor.shutdown();\n        \n        try {\n            // Đợi tất cả tasks hoàn thành\n            if (!executor.awaitTermination(30, TimeUnit.SECONDS)) {\n                executor.shutdownNow();\n            }\n        } catch (InterruptedException e) {\n            executor.shutdownNow();\n        }\n        \n        System.out.println(\"Tất cả tasks đã hoàn thành\");\n    }\n}\n```\n\n### Callable và Future\n\n```java\nimport java.util.concurrent.*;\nimport java.util.*;\n\npublic class CallableFutureExample {\n    public static void main(String[] args) {\n        ExecutorService executor = Executors.newFixedThreadPool(3);\n        \n        // Danh sách Future để lưu kết quả\n        List<Future<Integer>> futures = new ArrayList<>();\n        \n        // Submit Callable tasks\n        for (int i = 1; i <= 5; i++) {\n            final int taskId = i;\n            Future<Integer> future = executor.submit(() -> {\n                System.out.println(\"Task \" + taskId + \" đang chạy...\");\n                Thread.sleep(2000);\n                return taskId * taskId; // Trả về bình phương\n            });\n            futures.add(future);\n        }\n        \n        // Lấy kết quả từ Future\n        for (int i = 0; i < futures.size(); i++) {\n            try {\n                Future<Integer> future = futures.get(i);\n                Integer result = future.get(); // Blocking call\n                System.out.println(\"Task \" + (i + 1) + \" kết quả: \" + result);\n            } catch (InterruptedException | ExecutionException e) {\n                System.out.println(\"Lỗi khi lấy kết quả: \" + e.getMessage());\n            }\n        }\n        \n        executor.shutdown();\n    }\n}\n```\n\n## Concurrent Collections\n\n### Thread-Safe Collections\n\n```java\nimport java.util.concurrent.*;\nimport java.util.*;\n\npublic class ConcurrentCollectionsExample {\n    public static void main(String[] args) throws InterruptedException {\n        // ConcurrentHashMap - Thread-safe HashMap\n        ConcurrentHashMap<String, Integer> concurrentMap = new ConcurrentHashMap<>();\n        \n        // CopyOnWriteArrayList - Thread-safe ArrayList\n        CopyOnWriteArrayList<String> concurrentList = new CopyOnWriteArrayList<>();\n        \n        // BlockingQueue - Thread-safe Queue\n        BlockingQueue<String> blockingQueue = new ArrayBlockingQueue<>(10);\n        \n        // Producer thread\n        Thread producer = new Thread(() -> {\n            for (int i = 1; i <= 5; i++) {\n                String data = \"Data \" + i;\n                concurrentMap.put(\"key\" + i, i);\n                concurrentList.add(data);\n                \n                try {\n                    blockingQueue.put(data);\n                    System.out.println(\"Producer thêm: \" + data);\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    break;\n                }\n            }\n        });\n        \n        // Consumer thread\n        Thread consumer = new Thread(() -> {\n            for (int i = 1; i <= 5; i++) {\n                try {\n                    String data = blockingQueue.take();\n                    System.out.println(\"Consumer lấy: \" + data);\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    break;\n                }\n            }\n        });\n        \n        producer.start();\n        consumer.start();\n        \n        producer.join();\n        consumer.join();\n        \n        System.out.println(\"ConcurrentMap: \" + concurrentMap);\n        System.out.println(\"ConcurrentList: \" + concurrentList);\n    }\n}\n```\n\n## Atomic Operations\n\n### Atomic Variables\n\n```java\nimport java.util.concurrent.atomic.*;\nimport java.util.concurrent.*;\n\npublic class AtomicExample {\n    private static AtomicInteger atomicCounter = new AtomicInteger(0);\n    private static AtomicReference<String> atomicReference = new AtomicReference<>(\"Initial\");\n    \n    public static void main(String[] args) throws InterruptedException {\n        ExecutorService executor = Executors.newFixedThreadPool(5);\n        \n        // Submit tasks để tăng atomic counter\n        for (int i = 0; i < 10; i++) {\n            executor.submit(() -> {\n                for (int j = 0; j < 100; j++) {\n                    atomicCounter.incrementAndGet(); // Thread-safe increment\n                }\n            });\n        }\n        \n        // Submit tasks để update atomic reference\n        for (int i = 0; i < 5; i++) {\n            final int taskId = i;\n            executor.submit(() -> {\n                String newValue = \"Value from task \" + taskId;\n                atomicReference.set(newValue);\n                System.out.println(\"Updated reference to: \" + newValue);\n            });\n        }\n        \n        executor.shutdown();\n        executor.awaitTermination(10, TimeUnit.SECONDS);\n        \n        System.out.println(\"Final atomic counter: \" + atomicCounter.get());\n        System.out.println(\"Final atomic reference: \" + atomicReference.get());\n    }\n}\n```\n\n## Best Practices\n\n### 1. Sử dụng Executor Framework\n\n```java\n// Tốt - sử dụng ExecutorService\nExecutorService executor = Executors.newFixedThreadPool(10);\nexecutor.submit(() -> {\n    // Do work\n});\nexecutor.shutdown();\n\n// Tránh - tạo thread trực tiếp\nThread thread = new Thread(() -> {\n    // Do work\n});\nthread.start();\n```\n\n### 2. Sử dụng Concurrent Collections\n\n```java\n// Tốt - sử dụng concurrent collections\nConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();\nCopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<>();\n\n// Tránh - sử dụng synchronized collections\nMap<String, Integer> syncMap = Collections.synchronizedMap(new HashMap<>());\nList<String> syncList = Collections.synchronizedList(new ArrayList<>());\n```\n\n### 3. Sử dụng Atomic Variables\n\n```java\n// Tốt - sử dụng atomic variables\nAtomicInteger counter = new AtomicInteger(0);\ncounter.incrementAndGet();\n\n// Tránh - sử dụng synchronized cho simple operations\nprivate int counter = 0;\npublic synchronized void increment() {\n    counter++;\n}\n```\n\n### 4. Proper Resource Management\n\n```java\n// Tốt - proper shutdown\nExecutorService executor = Executors.newFixedThreadPool(5);\ntry {\n    // Submit tasks\n} finally {\n    executor.shutdown();\n    try {\n        if (!executor.awaitTermination(60, TimeUnit.SECONDS)) {\n            executor.shutdownNow();\n        }\n    } catch (InterruptedException e) {\n        executor.shutdownNow();\n        Thread.currentThread().interrupt();\n    }\n}\n```\n\n## Kết luận\n\nMultithreading và Concurrency trong Java cung cấp:\n\n1. **Thread Creation**: Extends Thread, Implements Runnable, Lambda\n2. **Synchronization**: synchronized, wait/notify\n3. **Executor Framework**: ThreadPool, Callable/Future\n4. **Concurrent Collections**: Thread-safe data structures\n5. **Atomic Operations**: Lock-free programming\n\n### Lưu ý quan trọng:\n\n- **Race conditions** có thể xảy ra khi không đồng bộ\n- **Deadlock** khi các thread chờ đợi lẫn nhau\n- **Thread safety** cần được đảm bảo\n- **Resource management** cần được xử lý đúng\n- **Performance** có thể bị ảnh hưởng bởi context switching\n\n### Best Practices:\n\n- Sử dụng **Executor Framework** thay vì tạo thread trực tiếp\n- Sử dụng **Concurrent Collections** cho thread safety\n- Sử dụng **Atomic Variables** cho simple operations\n- **Proper shutdown** của ExecutorService\n- **Avoid synchronized** khi có thể dùng atomic operations\n- **Minimize shared state** để giảm complexity\n\nHãy thực hành các ví dụ trên để nắm vững Multithreading và Concurrency trong Java!",
  "excerpt": "Tìm hiểu Multithreading và Concurrency trong Java - từ tạo thread, synchronization đến Executor Framework và best practices.",
  "author": "TRAN NHAN",
  "category": "Java Multithreading",
  "tags": ["Java", "Multithreading", "Concurrency", "Thread Safety"],
  "featuredImageUrl": "https://images.unsplash.com/photo-1555066931-4365d14bab8c?w=400&h=250&fit=crop&crop=center",
  "isPublished": true,
  "createdDate": "2024-01-25T16:45:00Z",
  "updatedDate": "2024-01-25T16:45:00Z",
  "viewCount": 720
}