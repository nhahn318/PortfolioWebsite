{
  "id": 6,
  "title": "Spring Framework: Dependency Injection và IoC Container",
  "content": "# Spring Framework: Dependency Injection và IoC Container\n\n## Giới thiệu về Spring Framework\n\nSpring Framework là một framework phổ biến nhất cho việc phát triển ứng dụng Java Enterprise. Nó cung cấp một kiến trúc toàn diện để xây dựng các ứng dụng Java từ cơ bản đến phức tạp.\n\n### Tại sao sử dụng Spring?\n\n1. **Dependency Injection**: Quản lý dependencies tự động\n2. **Inversion of Control**: Framework quản lý lifecycle của objects\n3. **Aspect-Oriented Programming**: Xử lý cross-cutting concerns\n4. **Modularity**: Chỉ sử dụng những module cần thiết\n5. **Testability**: Dễ dàng test với mock objects\n6. **Enterprise Features**: Security, Transaction, Web MVC\n\n### Core Modules của Spring:\n\n- **Core Container**: IoC container, Dependency Injection\n- **Data Access**: JDBC, ORM, Transaction\n- **Web**: Web MVC, WebSocket\n- **AOP**: Aspect-Oriented Programming\n- **Test**: Testing framework\n\n## Dependency Injection (DI)\n\n### Vấn đề không sử dụng DI\n\n```java\n// Tight coupling - khó test và maintain\npublic class OrderService {\n    private EmailService emailService;\n    private PaymentService paymentService;\n    \n    public OrderService() {\n        // Hard-coded dependencies\n        this.emailService = new EmailService();\n        this.paymentService = new PaymentService();\n    }\n    \n    public void processOrder(Order order) {\n        paymentService.processPayment(order);\n        emailService.sendConfirmation(order);\n    }\n}\n\nclass EmailService {\n    public void sendConfirmation(Order order) {\n        System.out.println(\"Gửi email xác nhận cho: \" + order.getCustomerEmail());\n    }\n}\n\nclass PaymentService {\n    public void processPayment(Order order) {\n        System.out.println(\"Xử lý thanh toán: \" + order.getAmount());\n    }\n}\n\nclass Order {\n    private String customerEmail;\n    private double amount;\n    \n    public Order(String customerEmail, double amount) {\n        this.customerEmail = customerEmail;\n        this.amount = amount;\n    }\n    \n    public String getCustomerEmail() { return customerEmail; }\n    public double getAmount() { return amount; }\n}\n```\n\n### Constructor Injection\n\n```java\n// Loose coupling với Constructor Injection\npublic class OrderService {\n    private final EmailService emailService;\n    private final PaymentService paymentService;\n    \n    // Constructor Injection\n    public OrderService(EmailService emailService, PaymentService paymentService) {\n        this.emailService = emailService;\n        this.paymentService = paymentService;\n    }\n    \n    public void processOrder(Order order) {\n        paymentService.processPayment(order);\n        emailService.sendConfirmation(order);\n    }\n}\n\n// Interface để dễ dàng mock trong test\ninterface EmailService {\n    void sendConfirmation(Order order);\n}\n\ninterface PaymentService {\n    void processPayment(Order order);\n}\n\n// Implementation\nclass EmailServiceImpl implements EmailService {\n    @Override\n    public void sendConfirmation(Order order) {\n        System.out.println(\"Gửi email xác nhận cho: \" + order.getCustomerEmail());\n    }\n}\n\nclass PaymentServiceImpl implements PaymentService {\n    @Override\n    public void processPayment(Order order) {\n        System.out.println(\"Xử lý thanh toán: \" + order.getAmount());\n    }\n}\n```\n\n### Setter Injection\n\n```java\n// Setter Injection\npublic class OrderService {\n    private EmailService emailService;\n    private PaymentService paymentService;\n    \n    // Setter Injection\n    public void setEmailService(EmailService emailService) {\n        this.emailService = emailService;\n    }\n    \n    public void setPaymentService(PaymentService paymentService) {\n        this.paymentService = paymentService;\n    }\n    \n    public void processOrder(Order order) {\n        paymentService.processPayment(order);\n        emailService.sendConfirmation(order);\n    }\n}\n```\n\n## Spring IoC Container\n\n### XML Configuration\n\n```xml\n<!-- applicationContext.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\">\n    \n    <!-- Bean definitions -->\n    <bean id=\"emailService\" class=\"com.example.EmailServiceImpl\" />\n    <bean id=\"paymentService\" class=\"com.example.PaymentServiceImpl\" />\n    \n    <!-- Constructor Injection -->\n    <bean id=\"orderService\" class=\"com.example.OrderService\">\n        <constructor-arg ref=\"emailService\" />\n        <constructor-arg ref=\"paymentService\" />\n    </bean>\n    \n    <!-- Setter Injection -->\n    <bean id=\"orderServiceSetter\" class=\"com.example.OrderService\">\n        <property name=\"emailService\" ref=\"emailService\" />\n        <property name=\"paymentService\" ref=\"paymentService\" />\n    </bean>\n    \n</beans>\n```\n\n### Java Configuration\n\n```java\nimport org.springframework.context.annotation.*;\n\n@Configuration\n@ComponentScan(basePackages = \"com.example\")\npublic class AppConfig {\n    \n    @Bean\n    public EmailService emailService() {\n        return new EmailServiceImpl();\n    }\n    \n    @Bean\n    public PaymentService paymentService() {\n        return new PaymentServiceImpl();\n    }\n    \n    @Bean\n    public OrderService orderService(EmailService emailService, PaymentService paymentService) {\n        return new OrderService(emailService, paymentService);\n    }\n}\n```\n\n### Annotation-based Configuration\n\n```java\nimport org.springframework.stereotype.*;\nimport org.springframework.beans.factory.annotation.*;\n\n// Service layer\n@Service\npublic class OrderService {\n    private final EmailService emailService;\n    private final PaymentService paymentService;\n    \n    // Constructor Injection với @Autowired\n    @Autowired\n    public OrderService(EmailService emailService, PaymentService paymentService) {\n        this.emailService = emailService;\n        this.paymentService = paymentService;\n    }\n    \n    public void processOrder(Order order) {\n        paymentService.processPayment(order);\n        emailService.sendConfirmation(order);\n    }\n}\n\n// Repository layer\n@Repository\npublic class OrderRepository {\n    public void save(Order order) {\n        System.out.println(\"Lưu order: \" + order);\n    }\n}\n\n// Service implementations\n@Service\npublic class EmailServiceImpl implements EmailService {\n    @Override\n    public void sendConfirmation(Order order) {\n        System.out.println(\"Gửi email xác nhận cho: \" + order.getCustomerEmail());\n    }\n}\n\n@Service\npublic class PaymentServiceImpl implements PaymentService {\n    @Override\n    public void processPayment(Order order) {\n        System.out.println(\"Xử lý thanh toán: \" + order.getAmount());\n    }\n}\n```\n\n## Bean Lifecycle\n\n### Bean Lifecycle Callbacks\n\n```java\nimport org.springframework.beans.factory.*;\nimport javax.annotation.*;\n\n@Component\npublic class LifecycleBean implements InitializingBean, DisposableBean {\n    \n    private String name;\n    \n    public LifecycleBean() {\n        System.out.println(\"1. Constructor called\");\n    }\n    \n    @PostConstruct\n    public void postConstruct() {\n        System.out.println(\"2. @PostConstruct called\");\n    }\n    \n    @Override\n    public void afterPropertiesSet() throws Exception {\n        System.out.println(\"3. InitializingBean.afterPropertiesSet() called\");\n    }\n    \n    public void initMethod() {\n        System.out.println(\"4. Custom init method called\");\n    }\n    \n    @PreDestroy\n    public void preDestroy() {\n        System.out.println(\"5. @PreDestroy called\");\n    }\n    \n    @Override\n    public void destroy() throws Exception {\n        System.out.println(\"6. DisposableBean.destroy() called\");\n    }\n    \n    public void destroyMethod() {\n        System.out.println(\"7. Custom destroy method called\");\n    }\n    \n    public String getName() { return name; }\n    public void setName(String name) { this.name = name; }\n}\n```\n\n### Bean Scope\n\n```java\nimport org.springframework.context.annotation.*;\n\n@Configuration\npublic class ScopeConfig {\n    \n    // Singleton scope (default)\n    @Bean\n    @Scope(\"singleton\")\n    public SingletonBean singletonBean() {\n        return new SingletonBean();\n    }\n    \n    // Prototype scope\n    @Bean\n    @Scope(\"prototype\")\n    public PrototypeBean prototypeBean() {\n        return new PrototypeBean();\n    }\n    \n    // Request scope (web applications)\n    @Bean\n    @Scope(\"request\")\n    public RequestBean requestBean() {\n        return new RequestBean();\n    }\n    \n    // Session scope (web applications)\n    @Bean\n    @Scope(\"session\")\n    public SessionBean sessionBean() {\n        return new SessionBean();\n    }\n}\n\nclass SingletonBean {\n    public SingletonBean() {\n        System.out.println(\"SingletonBean created\");\n    }\n}\n\nclass PrototypeBean {\n    public PrototypeBean() {\n        System.out.println(\"PrototypeBean created\");\n    }\n}\n\nclass RequestBean {\n    public RequestBean() {\n        System.out.println(\"RequestBean created\");\n    }\n}\n\nclass SessionBean {\n    public SessionBean() {\n        System.out.println(\"SessionBean created\");\n    }\n}\n```\n\n## Application Context\n\n### Sử dụng ApplicationContext\n\n```java\nimport org.springframework.context.*;\nimport org.springframework.context.support.*;\n\npublic class SpringApplication {\n    public static void main(String[] args) {\n        // XML Configuration\n        ApplicationContext xmlContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n        \n        // Java Configuration\n        ApplicationContext javaContext = new AnnotationConfigApplicationContext(AppConfig.class);\n        \n        // Lấy bean từ context\n        OrderService orderService = xmlContext.getBean(\"orderService\", OrderService.class);\n        \n        // Tạo order và xử lý\n        Order order = new Order(\"customer@example.com\", 100.0);\n        orderService.processOrder(order);\n        \n        // Đóng context\n        ((ClassPathXmlApplicationContext) xmlContext).close();\n        ((AnnotationConfigApplicationContext) javaContext).close();\n    }\n}\n```\n\n## Spring Boot Integration\n\n### Spring Boot Application\n\n```java\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.ConfigurableApplicationContext;\n\n@SpringBootApplication\npublic class SpringBootApp {\n    public static void main(String[] args) {\n        ConfigurableApplicationContext context = SpringApplication.run(SpringBootApp.class, args);\n        \n        // Lấy bean từ Spring Boot context\n        OrderService orderService = context.getBean(OrderService.class);\n        \n        Order order = new Order(\"customer@example.com\", 100.0);\n        orderService.processOrder(order);\n        \n        context.close();\n    }\n}\n```\n\n### Application Properties\n\n```properties\n# application.properties\n# Database Configuration\nspring.datasource.url=jdbc:mysql://localhost:3306/springdb\nspring.datasource.username=root\nspring.datasource.password=password\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\n\n# JPA Configuration\nspring.jpa.hibernate.ddl-auto=update\nspring.jpa.show-sql=true\nspring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect\n\n# Logging\nlogging.level.com.example=DEBUG\nlogging.level.org.springframework=INFO\n\n# Server Configuration\nserver.port=8080\nserver.servlet.context-path=/api\n```\n\n## Advanced Features\n\n### Conditional Beans\n\n```java\nimport org.springframework.context.annotation.*;\nimport org.springframework.boot.autoconfigure.condition.*;\n\n@Configuration\npublic class ConditionalConfig {\n    \n    @Bean\n    @ConditionalOnProperty(name = \"app.email.enabled\", havingValue = \"true\")\n    public EmailService emailService() {\n        return new EmailServiceImpl();\n    }\n    \n    @Bean\n    @ConditionalOnProperty(name = \"app.email.enabled\", havingValue = \"false\")\n    public EmailService mockEmailService() {\n        return new MockEmailService();\n    }\n    \n    @Bean\n    @ConditionalOnClass(name = \"com.mysql.cj.jdbc.Driver\")\n    public DatabaseService mysqlDatabaseService() {\n        return new MySQLDatabaseService();\n    }\n    \n    @Bean\n    @ConditionalOnMissingClass(\"com.mysql.cj.jdbc.Driver\")\n    public DatabaseService h2DatabaseService() {\n        return new H2DatabaseService();\n    }\n}\n\nclass MockEmailService implements EmailService {\n    @Override\n    public void sendConfirmation(Order order) {\n        System.out.println(\"Mock: Gửi email xác nhận cho: \" + order.getCustomerEmail());\n    }\n}\n\ninterface DatabaseService {\n    void connect();\n}\n\nclass MySQLDatabaseService implements DatabaseService {\n    @Override\n    public void connect() {\n        System.out.println(\"Kết nối MySQL database\");\n    }\n}\n\nclass H2DatabaseService implements DatabaseService {\n    @Override\n    public void connect() {\n        System.out.println(\"Kết nối H2 database\");\n    }\n}\n```\n\n### Profile-based Configuration\n\n```java\nimport org.springframework.context.annotation.*;\n\n@Configuration\npublic class ProfileConfig {\n    \n    @Bean\n    @Profile(\"dev\")\n    public EmailService devEmailService() {\n        return new DevEmailService();\n    }\n    \n    @Bean\n    @Profile(\"prod\")\n    public EmailService prodEmailService() {\n        return new ProdEmailService();\n    }\n    \n    @Bean\n    @Profile(\"test\")\n    public EmailService testEmailService() {\n        return new TestEmailService();\n    }\n}\n\nclass DevEmailService implements EmailService {\n    @Override\n    public void sendConfirmation(Order order) {\n        System.out.println(\"DEV: Gửi email xác nhận cho: \" + order.getCustomerEmail());\n    }\n}\n\nclass ProdEmailService implements EmailService {\n    @Override\n    public void sendConfirmation(Order order) {\n        System.out.println(\"PROD: Gửi email xác nhận cho: \" + order.getCustomerEmail());\n    }\n}\n\nclass TestEmailService implements EmailService {\n    @Override\n    public void sendConfirmation(Order order) {\n        System.out.println(\"TEST: Mock email gửi cho: \" + order.getCustomerEmail());\n    }\n}\n```\n\n## Testing với Spring\n\n### Unit Test với Mock\n\n```java\nimport org.junit.jupiter.api.*;\nimport org.mockito.*;\nimport static org.mockito.Mockito.*;\n\n@ExtendWith(MockitoExtension.class)\nclass OrderServiceTest {\n    \n    @Mock\n    private EmailService emailService;\n    \n    @Mock\n    private PaymentService paymentService;\n    \n    @InjectMocks\n    private OrderService orderService;\n    \n    @Test\n    void testProcessOrder() {\n        // Given\n        Order order = new Order(\"test@example.com\", 100.0);\n        \n        // When\n        orderService.processOrder(order);\n        \n        // Then\n        verify(paymentService).processPayment(order);\n        verify(emailService).sendConfirmation(order);\n    }\n}\n```\n\n### Integration Test\n\n```java\nimport org.junit.jupiter.api.*;\nimport org.springframework.boot.test.context.*;\nimport org.springframework.test.context.*;\nimport org.springframework.beans.factory.annotation.*;\n\n@SpringBootTest\n@TestPropertySource(properties = {\n    \"app.email.enabled=true\",\n    \"spring.profiles.active=test\"\n})\nclass OrderServiceIntegrationTest {\n    \n    @Autowired\n    private OrderService orderService;\n    \n    @Test\n    void testProcessOrderIntegration() {\n        // Given\n        Order order = new Order(\"test@example.com\", 100.0);\n        \n        // When\n        orderService.processOrder(order);\n        \n        // Then - verify behavior through logs or database\n        // (In real test, you might check database or external service calls)\n    }\n}\n```\n\n## Best Practices\n\n### 1. Sử dụng Constructor Injection\n\n```java\n// Tốt - Constructor Injection\n@Service\npublic class OrderService {\n    private final EmailService emailService;\n    private final PaymentService paymentService;\n    \n    public OrderService(EmailService emailService, PaymentService paymentService) {\n        this.emailService = emailService;\n        this.paymentService = paymentService;\n    }\n}\n\n// Tránh - Field Injection\n@Service\npublic class OrderServiceBad {\n    @Autowired\n    private EmailService emailService;\n    \n    @Autowired\n    private PaymentService paymentService;\n}\n```\n\n### 2. Sử dụng Interface\n\n```java\n// Tốt - sử dụng interface\n@Service\npublic class OrderService {\n    private final EmailService emailService; // Interface\n    \n    public OrderService(EmailService emailService) {\n        this.emailService = emailService;\n    }\n}\n\n// Tránh - sử dụng concrete class\n@Service\npublic class OrderServiceBad {\n    private final EmailServiceImpl emailService; // Concrete class\n    \n    public OrderService(EmailServiceImpl emailService) {\n        this.emailService = emailService;\n    }\n}\n```\n\n### 3. Proper Bean Naming\n\n```java\n// Tốt - sử dụng @Component với tên rõ ràng\n@Component(\"orderService\")\npublic class OrderService {\n    // ...\n}\n\n// Hoặc sử dụng @Service (tự động tạo tên)\n@Service\npublic class OrderService {\n    // ...\n}\n```\n\n## Kết luận\n\nSpring Framework cung cấp:\n\n1. **Dependency Injection**: Giảm coupling giữa các components\n2. **Inversion of Control**: Framework quản lý object lifecycle\n3. **Configuration**: XML, Java, hoặc Annotation-based\n4. **Bean Management**: Lifecycle, scope, và conditional beans\n5. **Testing Support**: Mock và integration testing\n\n### Lợi ích chính:\n\n- **Loose Coupling**: Components độc lập với nhau\n- **Testability**: Dễ dàng mock dependencies\n- **Maintainability**: Code dễ bảo trì và mở rộng\n- **Flexibility**: Có thể thay đổi implementation dễ dàng\n- **Enterprise Ready**: Hỗ trợ các tính năng enterprise\n\n### Best Practices:\n\n- Sử dụng **Constructor Injection** thay vì Field Injection\n- Sử dụng **Interface** thay vì concrete classes\n- **Proper bean naming** và organization\n- **Profile-based configuration** cho different environments\n- **Conditional beans** cho feature toggles\n- **Comprehensive testing** với Spring Test\n\nHãy thực hành các ví dụ trên để nắm vững Spring Framework và Dependency Injection!",
  "excerpt": "Tìm hiểu Spring Framework - Dependency Injection, IoC Container, Bean lifecycle và best practices cho ứng dụng Java Enterprise.",
  "author": "TRAN NHAN",
  "category": "Spring Framework",
  "tags": ["Spring", "Dependency Injection", "IoC", "Java Framework"],
  "featuredImageUrl": "https://images.unsplash.com/photo-1555066931-4365d14bab8c?w=400&h=250&fit=crop&crop=center",
  "isPublished": true,
  "createdDate": "2024-01-28T10:30:00Z",
  "updatedDate": "2024-01-28T10:30:00Z",
  "viewCount": 650
}