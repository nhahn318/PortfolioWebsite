{
  "id": 3,
  "title": "Java Collections Framework: Quản Lý Dữ Liệu Hiệu Quả",
  "content": "# Java Collections Framework: Quản Lý Dữ Liệu Hiệu Quả\n\n## Giới thiệu về Collections Framework\n\nJava Collections Framework là một kiến trúc thống nhất để biểu diễn và thao tác với các collections. Nó giúp giảm thiểu công việc lập trình và tăng hiệu suất và chất lượng chương trình.\n\n### Tại sao cần Collections Framework?\n\n1. **Tái sử dụng code**: Không cần viết lại cấu trúc dữ liệu\n2. **Hiệu suất cao**: Được tối ưu hóa cho từng trường hợp sử dụng\n3. **Type safety**: Sử dụng Generics để đảm bảo an toàn kiểu dữ liệu\n4. **Dễ sử dụng**: API đơn giản và nhất quán\n5. **Linh hoạt**: Nhiều implementation khác nhau cho cùng một interface\n\n### Các interface chính:\n\n1. **Collection**: Interface gốc cho tất cả collections\n2. **List**: Danh sách có thứ tự, cho phép duplicate\n3. **Set**: Tập hợp không có thứ tự, không cho phép duplicate\n4. **Map**: Cặp key-value, không extends Collection\n5. **Queue**: Hàng đợi FIFO (First In, First Out)\n\n## List Interface\n\n### ArrayList - Danh sách động\n\n```java\nimport java.util.*;\n\npublic class ArrayListExample {\n    public static void main(String[] args) {\n        // Tạo ArrayList với Generics\n        List<String> fruits = new ArrayList<>();\n        \n        // Thêm phần tử\n        fruits.add(\"Apple\");\n        fruits.add(\"Banana\");\n        fruits.add(\"Orange\");\n        fruits.add(1, \"Grape\"); // Thêm vào vị trí 1\n        \n        // Truy cập phần tử\n        System.out.println(\"First fruit: \" + fruits.get(0));\n        System.out.println(\"Size: \" + fruits.size());\n        \n        // Kiểm tra tồn tại\n        if (fruits.contains(\"Apple\")) {\n            System.out.println(\"Apple có trong danh sách\");\n        }\n        \n        // Duyệt qua danh sách\n        System.out.println(\"\\nDuyệt bằng for-each:\");\n        for (String fruit : fruits) {\n            System.out.println(fruit);\n        }\n        \n        // Sử dụng Iterator\n        System.out.println(\"\\nDuyệt bằng Iterator:\");\n        Iterator<String> iterator = fruits.iterator();\n        while (iterator.hasNext()) {\n            System.out.println(iterator.next());\n        }\n        \n        // Xóa phần tử\n        fruits.remove(\"Banana\");\n        fruits.remove(0); // Xóa phần tử đầu tiên\n        \n        System.out.println(\"\\nSau khi xóa: \" + fruits);\n    }\n}\n```\n\n### LinkedList - Danh sách liên kết\n\n```java\nimport java.util.*;\n\npublic class LinkedListExample {\n    public static void main(String[] args) {\n        LinkedList<Integer> numbers = new LinkedList<>();\n        \n        // Thêm vào đầu và cuối\n        numbers.addFirst(1);\n        numbers.addLast(3);\n        numbers.add(1, 2); // Thêm vào vị trí 1\n        numbers.addLast(4);\n        numbers.addLast(5);\n        \n        System.out.println(\"LinkedList: \" + numbers);\n        \n        // Truy cập phần tử đầu và cuối\n        System.out.println(\"First: \" + numbers.getFirst());\n        System.out.println(\"Last: \" + numbers.getLast());\n        \n        // Xóa phần tử đầu và cuối\n        numbers.removeFirst();\n        numbers.removeLast();\n        \n        System.out.println(\"Sau khi xóa đầu và cuối: \" + numbers);\n        \n        // LinkedList hiệu quả cho thao tác đầu/cuối\n        // ArrayList hiệu quả cho truy cập ngẫu nhiên\n    }\n}\n```\n\n## Set Interface\n\n### HashSet - Tập hợp không có thứ tự\n\n```java\nimport java.util.*;\n\npublic class HashSetExample {\n    public static void main(String[] args) {\n        Set<String> uniqueNames = new HashSet<>();\n        \n        // Thêm phần tử\n        uniqueNames.add(\"John\");\n        uniqueNames.add(\"Jane\");\n        uniqueNames.add(\"John\"); // Không được thêm vì đã tồn tại\n        uniqueNames.add(\"Bob\");\n        uniqueNames.add(\"Alice\");\n        \n        System.out.println(\"Size: \" + uniqueNames.size()); // 4\n        System.out.println(\"HashSet: \" + uniqueNames);\n        \n        // Kiểm tra tồn tại\n        if (uniqueNames.contains(\"John\")) {\n            System.out.println(\"John exists in set\");\n        }\n        \n        // Xóa phần tử\n        uniqueNames.remove(\"Bob\");\n        System.out.println(\"Sau khi xóa Bob: \" + uniqueNames);\n        \n        // HashSet không đảm bảo thứ tự\n        // Sử dụng khi cần kiểm tra tồn tại nhanh\n    }\n}\n```\n\n### TreeSet - Tập hợp có thứ tự\n\n```java\nimport java.util.*;\n\npublic class TreeSetExample {\n    public static void main(String[] args) {\n        TreeSet<Integer> sortedNumbers = new TreeSet<>();\n        \n        // Thêm phần tử (tự động sắp xếp)\n        sortedNumbers.add(5);\n        sortedNumbers.add(2);\n        sortedNumbers.add(8);\n        sortedNumbers.add(1);\n        sortedNumbers.add(3);\n        \n        System.out.println(\"TreeSet: \" + sortedNumbers); // [1, 2, 3, 5, 8]\n        \n        // Tìm phần tử nhỏ nhất và lớn nhất\n        System.out.println(\"Min: \" + sortedNumbers.first());\n        System.out.println(\"Max: \" + sortedNumbers.last());\n        \n        // Tìm phần tử nhỏ hơn hoặc lớn hơn\n        System.out.println(\"Floor of 4: \" + sortedNumbers.floor(4)); // 3\n        System.out.println(\"Ceiling of 4: \" + sortedNumbers.ceiling(4)); // 5\n        \n        // Lấy subset\n        System.out.println(\"HeadSet of 5: \" + sortedNumbers.headSet(5)); // [1, 2, 3]\n        System.out.println(\"TailSet of 3: \" + sortedNumbers.tailSet(3)); // [3, 5, 8]\n    }\n}\n```\n\n## Map Interface\n\n### HashMap - Bảng băm\n\n```java\nimport java.util.*;\n\npublic class HashMapExample {\n    public static void main(String[] args) {\n        Map<String, Integer> ageMap = new HashMap<>();\n        \n        // Thêm cặp key-value\n        ageMap.put(\"John\", 25);\n        ageMap.put(\"Jane\", 30);\n        ageMap.put(\"Bob\", 35);\n        ageMap.put(\"Alice\", 28);\n        \n        // Truy cập giá trị\n        System.out.println(\"John's age: \" + ageMap.get(\"John\"));\n        \n        // Kiểm tra key tồn tại\n        if (ageMap.containsKey(\"Jane\")) {\n            System.out.println(\"Jane exists in map\");\n        }\n        \n        // Kiểm tra value tồn tại\n        if (ageMap.containsValue(30)) {\n            System.out.println(\"Someone is 30 years old\");\n        }\n        \n        // Duyệt qua map\n        System.out.println(\"\\nDuyệt bằng entrySet:\");\n        for (Map.Entry<String, Integer> entry : ageMap.entrySet()) {\n            System.out.println(entry.getKey() + \": \" + entry.getValue());\n        }\n        \n        // Duyệt qua keys\n        System.out.println(\"\\nDuyệt qua keys:\");\n        for (String key : ageMap.keySet()) {\n            System.out.println(\"Key: \" + key);\n        }\n        \n        // Duyệt qua values\n        System.out.println(\"\\nDuyệt qua values:\");\n        for (Integer value : ageMap.values()) {\n            System.out.println(\"Value: \" + value);\n        }\n        \n        // Xóa phần tử\n        ageMap.remove(\"Bob\");\n        System.out.println(\"\\nSau khi xóa Bob: \" + ageMap);\n    }\n}\n```\n\n### TreeMap - Bảng có thứ tự\n\n```java\nimport java.util.*;\n\npublic class TreeMapExample {\n    public static void main(String[] args) {\n        TreeMap<String, Integer> sortedMap = new TreeMap<>();\n        \n        // Thêm phần tử (tự động sắp xếp theo key)\n        sortedMap.put(\"Charlie\", 30);\n        sortedMap.put(\"Alice\", 25);\n        sortedMap.put(\"Bob\", 35);\n        sortedMap.put(\"David\", 28);\n        \n        System.out.println(\"TreeMap: \" + sortedMap);\n        \n        // Tìm key nhỏ nhất và lớn nhất\n        System.out.println(\"First key: \" + sortedMap.firstKey());\n        System.out.println(\"Last key: \" + sortedMap.lastKey());\n        \n        // Lấy submap\n        System.out.println(\"HeadMap of 'C': \" + sortedMap.headMap(\"C\"));\n        System.out.println(\"TailMap of 'C': \" + sortedMap.tailMap(\"C\"));\n    }\n}\n```\n\n## Queue Interface\n\n### PriorityQueue - Hàng đợi ưu tiên\n\n```java\nimport java.util.*;\n\npublic class PriorityQueueExample {\n    public static void main(String[] args) {\n        // PriorityQueue với thứ tự tự nhiên\n        PriorityQueue<Integer> priorityQueue = new PriorityQueue<>();\n        \n        // Thêm phần tử\n        priorityQueue.offer(5);\n        priorityQueue.offer(2);\n        priorityQueue.offer(8);\n        priorityQueue.offer(1);\n        priorityQueue.offer(3);\n        \n        System.out.println(\"PriorityQueue: \" + priorityQueue);\n        \n        // Lấy phần tử có độ ưu tiên cao nhất (nhỏ nhất)\n        System.out.println(\"\\nLấy phần tử theo thứ tự ưu tiên:\");\n        while (!priorityQueue.isEmpty()) {\n            System.out.println(priorityQueue.poll());\n        }\n        // Output: 1, 2, 3, 5, 8\n        \n        // PriorityQueue với Comparator tùy chỉnh\n        PriorityQueue<String> customQueue = new PriorityQueue<>(\n            (s1, s2) -> s2.length() - s1.length() // Sắp xếp theo độ dài giảm dần\n        );\n        \n        customQueue.offer(\"Java\");\n        customQueue.offer(\"Python\");\n        customQueue.offer(\"C++\");\n        customQueue.offer(\"JavaScript\");\n        \n        System.out.println(\"\\nCustom PriorityQueue:\");\n        while (!customQueue.isEmpty()) {\n            System.out.println(customQueue.poll());\n        }\n        // Output: JavaScript, Python, Java, C++\n    }\n}\n```\n\n## Collections Utility Class\n\n### Các phương thức tiện ích\n\n```java\nimport java.util.*;\n\npublic class CollectionsUtilityExample {\n    public static void main(String[] args) {\n        List<Integer> numbers = new ArrayList<>();\n        numbers.add(5);\n        numbers.add(2);\n        numbers.add(8);\n        numbers.add(1);\n        numbers.add(3);\n        \n        System.out.println(\"Original list: \" + numbers);\n        \n        // Sắp xếp\n        Collections.sort(numbers);\n        System.out.println(\"Sorted: \" + numbers);\n        \n        // Đảo ngược\n        Collections.reverse(numbers);\n        System.out.println(\"Reversed: \" + numbers);\n        \n        // Trộn ngẫu nhiên\n        Collections.shuffle(numbers);\n        System.out.println(\"Shuffled: \" + numbers);\n        \n        // Tìm kiếm (cần sắp xếp trước)\n        Collections.sort(numbers);\n        int index = Collections.binarySearch(numbers, 3);\n        System.out.println(\"Index of 3: \" + index);\n        \n        // Tìm min, max\n        System.out.println(\"Min: \" + Collections.min(numbers));\n        System.out.println(\"Max: \" + Collections.max(numbers));\n        \n        // Đếm số lần xuất hiện\n        numbers.add(3);\n        numbers.add(3);\n        int count = Collections.frequency(numbers, 3);\n        System.out.println(\"Frequency of 3: \" + count);\n        \n        // Tạo list không thể thay đổi\n        List<String> immutableList = Collections.unmodifiableList(\n            Arrays.asList(\"A\", \"B\", \"C\")\n        );\n        // immutableList.add(\"D\"); // Sẽ throw UnsupportedOperationException\n    }\n}\n```\n\n## Generics và Type Safety\n\n### Sử dụng Generics\n\n```java\nimport java.util.*;\n\npublic class GenericsExample {\n    public static void main(String[] args) {\n        // Tốt - sử dụng Generics\n        List<String> stringList = new ArrayList<>();\n        stringList.add(\"Hello\");\n        stringList.add(\"World\");\n        // stringList.add(123); // Lỗi compile time!\n        \n        // Tránh - Raw types\n        List rawList = new ArrayList();\n        rawList.add(\"Hello\");\n        rawList.add(123); // Không an toàn\n        \n        // Generic method\n        List<Integer> intList = Arrays.asList(1, 2, 3, 4, 5);\n        List<String> strList = Arrays.asList(\"A\", \"B\", \"C\");\n        \n        printList(intList);\n        printList(strList);\n        \n        // Generic class\n        Box<String> stringBox = new Box<>();\n        stringBox.setContent(\"Hello\");\n        System.out.println(\"Box content: \" + stringBox.getContent());\n        \n        Box<Integer> intBox = new Box<>();\n        intBox.setContent(42);\n        System.out.println(\"Box content: \" + intBox.getContent());\n    }\n    \n    // Generic method\n    public static <T> void printList(List<T> list) {\n        for (T item : list) {\n            System.out.println(item);\n        }\n    }\n}\n\n// Generic class\nclass Box<T> {\n    private T content;\n    \n    public void setContent(T content) {\n        this.content = content;\n    }\n    \n    public T getContent() {\n        return content;\n    }\n}\n```\n\n## Best Practices\n\n### 1. Chọn đúng Collection\n\n```java\n// Sử dụng ArrayList khi:\n// - Cần truy cập ngẫu nhiên\n// - Ít thao tác thêm/xóa ở giữa\nList<String> list = new ArrayList<>();\n\n// Sử dụng LinkedList khi:\n// - Nhiều thao tác thêm/xóa ở đầu/cuối\n// - Ít truy cập ngẫu nhiên\nList<String> linkedList = new LinkedList<>();\n\n// Sử dụng HashSet khi:\n// - Cần kiểm tra tồn tại nhanh\n// - Không quan tâm thứ tự\nSet<String> set = new HashSet<>();\n\n// Sử dụng TreeSet khi:\n// - Cần thứ tự sắp xếp\n// - Cần tìm min/max\nSet<String> sortedSet = new TreeSet<>();\n\n// Sử dụng HashMap khi:\n// - Cần truy cập nhanh theo key\n// - Không quan tâm thứ tự\nMap<String, Integer> map = new HashMap<>();\n\n// Sử dụng TreeMap khi:\n// - Cần thứ tự sắp xếp theo key\n// - Cần range queries\nMap<String, Integer> sortedMap = new TreeMap<>();\n```\n\n### 2. Sử dụng Interface thay vì Implementation\n\n```java\n// Tốt\nList<String> list = new ArrayList<>();\nSet<Integer> set = new HashSet<>();\nMap<String, Object> map = new HashMap<>();\n\n// Tránh\nArrayList<String> list = new ArrayList<>();\nHashSet<Integer> set = new HashSet<>();\nHashMap<String, Object> map = new HashMap<>();\n```\n\n### 3. Sử dụng Enhanced for-loop\n\n```java\n// Tốt\nfor (String item : list) {\n    System.out.println(item);\n}\n\n// Tránh (trừ khi cần index)\nfor (int i = 0; i < list.size(); i++) {\n    System.out.println(list.get(i));\n}\n```\n\n### 4. Sử dụng Iterator khi cần xóa\n\n```java\n// Tốt - sử dụng Iterator\nIterator<String> iterator = list.iterator();\nwhile (iterator.hasNext()) {\n    String item = iterator.next();\n    if (item.startsWith(\"A\")) {\n        iterator.remove(); // An toàn\n    }\n}\n\n// Tránh - xóa trong for-loop\n// for (int i = 0; i < list.size(); i++) {\n//     if (list.get(i).startsWith(\"A\")) {\n//         list.remove(i); // Có thể gây lỗi\n//     }\n// }\n```\n\n## Kết luận\n\nJava Collections Framework cung cấp:\n\n1. **Cấu trúc dữ liệu mạnh mẽ**: List, Set, Map, Queue\n2. **Type safety**: Generics đảm bảo an toàn kiểu dữ liệu\n3. **Hiệu suất cao**: Được tối ưu hóa cho từng trường hợp\n4. **API nhất quán**: Dễ học và sử dụng\n5. **Linh hoạt**: Nhiều implementation khác nhau\n\n### Lưu ý quan trọng:\n\n- **Chọn đúng Collection** cho từng tình huống\n- **Sử dụng Generics** để đảm bảo type safety\n- **Sử dụng Interface** thay vì implementation\n- **Hiểu rõ complexity** của các thao tác\n- **Sử dụng Collections utility class** cho các thao tác phổ biến\n\nHãy thực hành các ví dụ trên để nắm vững Java Collections Framework!",
  "excerpt": "Tìm hiểu Java Collections Framework - bộ công cụ mạnh mẽ để quản lý dữ liệu. Từ List, Set, Map đến Queue và best practices.",
  "author": "TRAN NHAN",
  "category": "Java Collections",
  "tags": ["Java", "Collections", "Data Structures", "Framework"],
  "featuredImageUrl": "https://images.unsplash.com/photo-1555066931-4365d14bab8c?w=400&h=250&fit=crop&crop=center",
  "isPublished": true,
  "createdDate": "2024-01-20T14:30:00Z",
  "updatedDate": "2024-01-20T14:30:00Z",
  "viewCount": 980
}