{
  "id": 8,
  "title": "Java Database Connectivity (JDBC): Kết Nối Database",
  "content": "# Java Database Connectivity (JDBC): Kết Nối Database\n\n## Giới thiệu về JDBC\n\nJDBC (Java Database Connectivity) là API chuẩn của Java để kết nối và thao tác với cơ sở dữ liệu quan hệ. JDBC cung cấp một cách thống nhất để truy cập các loại database khác nhau.\n\n### Tại sao cần JDBC?\n\n1. **Database Independence**: Có thể thay đổi database mà không cần thay đổi code\n2. **Standard API**: Chuẩn hóa cách kết nối database\n3. **Performance**: Truy cập database hiệu quả\n4. **Flexibility**: Hỗ trợ nhiều loại database\n5. **Transaction Support**: Quản lý transaction\n6. **Connection Pooling**: Quản lý connection pool\n\n### JDBC Architecture:\n\n- **JDBC API**: Interface cho Java application\n- **JDBC Driver**: Implementation cho từng database\n- **Database**: MySQL, PostgreSQL, Oracle, SQL Server, etc.\n\n## JDBC Setup\n\n### Maven Dependencies\n\n```xml\n<!-- pom.xml -->\n<dependencies>\n    <!-- MySQL Driver -->\n    <dependency>\n        <groupId>mysql</groupId>\n        <artifactId>mysql-connector-java</artifactId>\n        <version>8.0.33</version>\n    </dependency>\n    \n    <!-- PostgreSQL Driver -->\n    <dependency>\n        <groupId>org.postgresql</groupId>\n        <artifactId>postgresql</artifactId>\n        <version>42.6.0</version>\n    </dependency>\n    \n    <!-- H2 Database (for testing) -->\n    <dependency>\n        <groupId>com.h2database</groupId>\n        <artifactId>h2</artifactId>\n        <version>2.1.214</version>\n        <scope>test</scope>\n    </dependency>\n    \n    <!-- Connection Pool -->\n    <dependency>\n        <groupId>com.zaxxer</groupId>\n        <artifactId>HikariCP</artifactId>\n        <version>5.0.1</version>\n    </dependency>\n</dependencies>\n```\n\n### Database Configuration\n\n```properties\n# database.properties\n# MySQL Configuration\ndb.mysql.url=jdbc:mysql://localhost:3306/jdbcdemo\ndb.mysql.username=root\ndb.mysql.password=password\ndb.mysql.driver=com.mysql.cj.jdbc.Driver\n\n# PostgreSQL Configuration\ndb.postgres.url=jdbc:postgresql://localhost:5432/jdbcdemo\ndb.postgres.username=postgres\ndb.postgres.password=password\ndb.postgres.driver=org.postgresql.Driver\n\n# H2 Configuration (for testing)\ndb.h2.url=jdbc:h2:mem:testdb\ndb.h2.username=sa\ndb.h2.password=\ndb.h2.driver=org.h2.Driver\n```\n\n## Basic JDBC Operations\n\n### Database Connection\n\n```java\nimport java.sql.*;\nimport java.util.Properties;\nimport java.io.*;\n\npublic class DatabaseConnection {\n    \n    public static Connection getConnection() throws SQLException {\n        // Load database properties\n        Properties props = new Properties();\n        try (InputStream input = DatabaseConnection.class.getClassLoader()\n                .getResourceAsStream(\"database.properties\")) {\n            props.load(input);\n        } catch (IOException e) {\n            throw new SQLException(\"Cannot load database properties\", e);\n        }\n        \n        String url = props.getProperty(\"db.mysql.url\");\n        String username = props.getProperty(\"db.mysql.username\");\n        String password = props.getProperty(\"db.mysql.password\");\n        \n        // Create connection\n        return DriverManager.getConnection(url, username, password);\n    }\n    \n    public static void main(String[] args) {\n        try (Connection conn = getConnection()) {\n            System.out.println(\"Kết nối database thành công!\");\n            System.out.println(\"Database: \" + conn.getMetaData().getDatabaseProductName());\n            System.out.println(\"Version: \" + conn.getMetaData().getDatabaseProductVersion());\n        } catch (SQLException e) {\n            System.err.println(\"Lỗi kết nối database: \" + e.getMessage());\n        }\n    }\n}\n```\n\n### Create Table\n\n```java\nimport java.sql.*;\n\npublic class CreateTableExample {\n    \n    public static void createUsersTable() {\n        String sql = \"\"\"\n            CREATE TABLE IF NOT EXISTS users (\n                id INT AUTO_INCREMENT PRIMARY KEY,\n                name VARCHAR(100) NOT NULL,\n                email VARCHAR(100) UNIQUE NOT NULL,\n                age INT,\n                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP\n            )\n            \"\"\";\n        \n        try (Connection conn = DatabaseConnection.getConnection();\n             Statement stmt = conn.createStatement()) {\n            \n            stmt.execute(sql);\n            System.out.println(\"Tạo bảng users thành công!\");\n            \n        } catch (SQLException e) {\n            System.err.println(\"Lỗi tạo bảng: \" + e.getMessage());\n        }\n    }\n    \n    public static void main(String[] args) {\n        createUsersTable();\n    }\n}\n```\n\n## CRUD Operations\n\n### User Model\n\n```java\nimport java.time.LocalDateTime;\n\npublic class User {\n    private Long id;\n    private String name;\n    private String email;\n    private Integer age;\n    private LocalDateTime createdAt;\n    private LocalDateTime updatedAt;\n    \n    // Constructors\n    public User() {}\n    \n    public User(String name, String email, Integer age) {\n        this.name = name;\n        this.email = email;\n        this.age = age;\n    }\n    \n    public User(Long id, String name, String email, Integer age, \n                LocalDateTime createdAt, LocalDateTime updatedAt) {\n        this.id = id;\n        this.name = name;\n        this.email = email;\n        this.age = age;\n        this.createdAt = createdAt;\n        this.updatedAt = updatedAt;\n    }\n    \n    // Getters and Setters\n    public Long getId() { return id; }\n    public void setId(Long id) { this.id = id; }\n    \n    public String getName() { return name; }\n    public void setName(String name) { this.name = name; }\n    \n    public String getEmail() { return email; }\n    public void setEmail(String email) { this.email = email; }\n    \n    public Integer getAge() { return age; }\n    public void setAge(Integer age) { this.age = age; }\n    \n    public LocalDateTime getCreatedAt() { return createdAt; }\n    public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }\n    \n    public LocalDateTime getUpdatedAt() { return updatedAt; }\n    public void setUpdatedAt(LocalDateTime updatedAt) { this.updatedAt = updatedAt; }\n    \n    @Override\n    public String toString() {\n        return \"User{id=\" + id + \", name='\" + name + \"', email='\" + email + \", age=\" + age + \"}\";\n    }\n}\n```\n\n### UserDAO (Data Access Object)\n\n```java\nimport java.sql.*;\nimport java.time.LocalDateTime;\nimport java.util.*;\n\npublic class UserDAO {\n    \n    // CREATE - Thêm user mới\n    public Long createUser(User user) throws SQLException {\n        String sql = \"INSERT INTO users (name, email, age) VALUES (?, ?, ?)\";\n        \n        try (Connection conn = DatabaseConnection.getConnection();\n             PreparedStatement pstmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {\n            \n            pstmt.setString(1, user.getName());\n            pstmt.setString(2, user.getEmail());\n            pstmt.setInt(3, user.getAge());\n            \n            int affectedRows = pstmt.executeUpdate();\n            \n            if (affectedRows > 0) {\n                try (ResultSet generatedKeys = pstmt.getGeneratedKeys()) {\n                    if (generatedKeys.next()) {\n                        return generatedKeys.getLong(1);\n                    }\n                }\n            }\n            \n            throw new SQLException(\"Tạo user thất bại, không có ID được tạo.\");\n        }\n    }\n    \n    // READ - Lấy user theo ID\n    public User getUserById(Long id) throws SQLException {\n        String sql = \"SELECT * FROM users WHERE id = ?\";\n        \n        try (Connection conn = DatabaseConnection.getConnection();\n             PreparedStatement pstmt = conn.prepareStatement(sql)) {\n            \n            pstmt.setLong(1, id);\n            \n            try (ResultSet rs = pstmt.executeQuery()) {\n                if (rs.next()) {\n                    return mapResultSetToUser(rs);\n                }\n            }\n        }\n        return null;\n    }\n    \n    // READ - Lấy tất cả users\n    public List<User> getAllUsers() throws SQLException {\n        String sql = \"SELECT * FROM users ORDER BY id\";\n        List<User> users = new ArrayList<>();\n        \n        try (Connection conn = DatabaseConnection.getConnection();\n             PreparedStatement pstmt = conn.prepareStatement(sql);\n             ResultSet rs = pstmt.executeQuery()) {\n            \n            while (rs.next()) {\n                users.add(mapResultSetToUser(rs));\n            }\n        }\n        return users;\n    }\n    \n    // UPDATE - Cập nhật user\n    public boolean updateUser(User user) throws SQLException {\n        String sql = \"UPDATE users SET name = ?, email = ?, age = ? WHERE id = ?\";\n        \n        try (Connection conn = DatabaseConnection.getConnection();\n             PreparedStatement pstmt = conn.prepareStatement(sql)) {\n            \n            pstmt.setString(1, user.getName());\n            pstmt.setString(2, user.getEmail());\n            pstmt.setInt(3, user.getAge());\n            pstmt.setLong(4, user.getId());\n            \n            return pstmt.executeUpdate() > 0;\n        }\n    }\n    \n    // DELETE - Xóa user\n    public boolean deleteUser(Long id) throws SQLException {\n        String sql = \"DELETE FROM users WHERE id = ?\";\n        \n        try (Connection conn = DatabaseConnection.getConnection();\n             PreparedStatement pstmt = conn.prepareStatement(sql)) {\n            \n            pstmt.setLong(1, id);\n            return pstmt.executeUpdate() > 0;\n        }\n    }\n    \n    // SEARCH - Tìm kiếm user theo tên\n    public List<User> searchUsersByName(String name) throws SQLException {\n        String sql = \"SELECT * FROM users WHERE name LIKE ? ORDER BY name\";\n        List<User> users = new ArrayList<>();\n        \n        try (Connection conn = DatabaseConnection.getConnection();\n             PreparedStatement pstmt = conn.prepareStatement(sql)) {\n            \n            pstmt.setString(1, \"%\" + name + \"%\");\n            \n            try (ResultSet rs = pstmt.executeQuery()) {\n                while (rs.next()) {\n                    users.add(mapResultSetToUser(rs));\n                }\n            }\n        }\n        return users;\n    }\n    \n    // COUNT - Đếm số users\n    public long countUsers() throws SQLException {\n        String sql = \"SELECT COUNT(*) FROM users\";\n        \n        try (Connection conn = DatabaseConnection.getConnection();\n             PreparedStatement pstmt = conn.prepareStatement(sql);\n             ResultSet rs = pstmt.executeQuery()) {\n            \n            if (rs.next()) {\n                return rs.getLong(1);\n            }\n        }\n        return 0;\n    }\n    \n    // Helper method để map ResultSet thành User object\n    private User mapResultSetToUser(ResultSet rs) throws SQLException {\n        User user = new User();\n        user.setId(rs.getLong(\"id\"));\n        user.setName(rs.getString(\"name\"));\n        user.setEmail(rs.getString(\"email\"));\n        user.setAge(rs.getInt(\"age\"));\n        \n        // Handle timestamp conversion\n        Timestamp createdAt = rs.getTimestamp(\"created_at\");\n        if (createdAt != null) {\n            user.setCreatedAt(createdAt.toLocalDateTime());\n        }\n        \n        Timestamp updatedAt = rs.getTimestamp(\"updated_at\");\n        if (updatedAt != null) {\n            user.setUpdatedAt(updatedAt.toLocalDateTime());\n        }\n        \n        return user;\n    }\n}\n```\n\n## Transaction Management\n\n### Transaction Example\n\n```java\nimport java.sql.*;\n\npublic class TransactionExample {\n    \n    public static void transferMoney(Long fromUserId, Long toUserId, double amount) {\n        Connection conn = null;\n        try {\n            conn = DatabaseConnection.getConnection();\n            \n            // Bắt đầu transaction\n            conn.setAutoCommit(false);\n            \n            // Kiểm tra số dư\n            double fromBalance = getBalance(conn, fromUserId);\n            if (fromBalance < amount) {\n                throw new SQLException(\"Số dư không đủ\");\n            }\n            \n            // Trừ tiền từ tài khoản gửi\n            updateBalance(conn, fromUserId, fromBalance - amount);\n            \n            // Cộng tiền vào tài khoản nhận\n            double toBalance = getBalance(conn, toUserId);\n            updateBalance(conn, toUserId, toBalance + amount);\n            \n            // Commit transaction\n            conn.commit();\n            System.out.println(\"Chuyển tiền thành công: \" + amount);\n            \n        } catch (SQLException e) {\n            // Rollback transaction nếu có lỗi\n            if (conn != null) {\n                try {\n                    conn.rollback();\n                    System.out.println(\"Transaction đã được rollback\");\n                } catch (SQLException rollbackEx) {\n                    System.err.println(\"Lỗi rollback: \" + rollbackEx.getMessage());\n                }\n            }\n            System.err.println(\"Lỗi chuyển tiền: \" + e.getMessage());\n        } finally {\n            if (conn != null) {\n                try {\n                    conn.setAutoCommit(true);\n                    conn.close();\n                } catch (SQLException e) {\n                    System.err.println(\"Lỗi đóng connection: \" + e.getMessage());\n                }\n            }\n        }\n    }\n    \n    private static double getBalance(Connection conn, Long userId) throws SQLException {\n        String sql = \"SELECT balance FROM accounts WHERE user_id = ?\";\n        try (PreparedStatement pstmt = conn.prepareStatement(sql)) {\n            pstmt.setLong(1, userId);\n            try (ResultSet rs = pstmt.executeQuery()) {\n                if (rs.next()) {\n                    return rs.getDouble(\"balance\");\n                }\n            }\n        }\n        throw new SQLException(\"Không tìm thấy tài khoản\");\n    }\n    \n    private static void updateBalance(Connection conn, Long userId, double newBalance) throws SQLException {\n        String sql = \"UPDATE accounts SET balance = ? WHERE user_id = ?\";\n        try (PreparedStatement pstmt = conn.prepareStatement(sql)) {\n            pstmt.setDouble(1, newBalance);\n            pstmt.setLong(2, userId);\n            pstmt.executeUpdate();\n        }\n    }\n}\n```\n\n## Connection Pooling\n\n### HikariCP Configuration\n\n```java\nimport com.zaxxer.hikari.*;\nimport java.sql.*;\n\npublic class ConnectionPoolManager {\n    private static HikariDataSource dataSource;\n    \n    static {\n        HikariConfig config = new HikariConfig();\n        config.setJdbcUrl(\"jdbc:mysql://localhost:3306/jdbcdemo\");\n        config.setUsername(\"root\");\n        config.setPassword(\"password\");\n        config.setDriverClassName(\"com.mysql.cj.jdbc.Driver\");\n        \n        // Connection pool settings\n        config.setMaximumPoolSize(20);\n        config.setMinimumIdle(5);\n        config.setConnectionTimeout(30000);\n        config.setIdleTimeout(600000);\n        config.setMaxLifetime(1800000);\n        config.setLeakDetectionThreshold(60000);\n        \n        // Connection test settings\n        config.setConnectionTestQuery(\"SELECT 1\");\n        config.setValidationTimeout(5000);\n        \n        dataSource = new HikariDataSource(config);\n    }\n    \n    public static Connection getConnection() throws SQLException {\n        return dataSource.getConnection();\n    }\n    \n    public static void closeDataSource() {\n        if (dataSource != null && !dataSource.isClosed()) {\n            dataSource.close();\n        }\n    }\n    \n    public static void printPoolStatus() {\n        System.out.println(\"Active connections: \" + dataSource.getHikariPoolMXBean().getActiveConnections());\n        System.out.println(\"Idle connections: \" + dataSource.getHikariPoolMXBean().getIdleConnections());\n        System.out.println(\"Total connections: \" + dataSource.getHikariPoolMXBean().getTotalConnections());\n    }\n}\n```\n\n## Batch Operations\n\n### Batch Insert\n\n```java\nimport java.sql.*;\nimport java.util.*;\n\npublic class BatchOperationsExample {\n    \n    public static void batchInsertUsers(List<User> users) {\n        String sql = \"INSERT INTO users (name, email, age) VALUES (?, ?, ?)\";\n        \n        try (Connection conn = ConnectionPoolManager.getConnection();\n             PreparedStatement pstmt = conn.prepareStatement(sql)) {\n            \n            // Bắt đầu batch\n            conn.setAutoCommit(false);\n            \n            for (User user : users) {\n                pstmt.setString(1, user.getName());\n                pstmt.setString(2, user.getEmail());\n                pstmt.setInt(3, user.getAge());\n                pstmt.addBatch();\n            }\n            \n            // Thực hiện batch\n            int[] results = pstmt.executeBatch();\n            \n            // Commit transaction\n            conn.commit();\n            \n            System.out.println(\"Batch insert thành công: \" + results.length + \" records\");\n            \n        } catch (SQLException e) {\n            System.err.println(\"Lỗi batch insert: \" + e.getMessage());\n        }\n    }\n    \n    public static void main(String[] args) {\n        List<User> users = Arrays.asList(\n            new User(\"John Doe\", \"john@example.com\", 25),\n            new User(\"Jane Smith\", \"jane@example.com\", 30),\n            new User(\"Bob Johnson\", \"bob@example.com\", 35),\n            new User(\"Alice Brown\", \"alice@example.com\", 28)\n        );\n        \n        batchInsertUsers(users);\n    }\n}\n```\n\n## Stored Procedures\n\n### Call Stored Procedure\n\n```java\nimport java.sql.*;\n\npublic class StoredProcedureExample {\n    \n    public static void callGetUserById(Long userId) {\n        String sql = \"{CALL GetUserById(?)}\";\n        \n        try (Connection conn = ConnectionPoolManager.getConnection();\n             CallableStatement cstmt = conn.prepareCall(sql)) {\n            \n            // Set input parameter\n            cstmt.setLong(1, userId);\n            \n            // Execute stored procedure\n            boolean hasResultSet = cstmt.execute();\n            \n            if (hasResultSet) {\n                try (ResultSet rs = cstmt.getResultSet()) {\n                    while (rs.next()) {\n                        System.out.println(\"User: \" + rs.getString(\"name\") + \n                                          \", Email: \" + rs.getString(\"email\"));\n                    }\n                }\n            }\n            \n        } catch (SQLException e) {\n            System.err.println(\"Lỗi gọi stored procedure: \" + e.getMessage());\n        }\n    }\n    \n    public static void callGetUserCount() {\n        String sql = \"{CALL GetUserCount(?)}\";\n        \n        try (Connection conn = ConnectionPoolManager.getConnection();\n             CallableStatement cstmt = conn.prepareCall(sql)) {\n            \n            // Register output parameter\n            cstmt.registerOutParameter(1, Types.INTEGER);\n            \n            // Execute stored procedure\n            cstmt.execute();\n            \n            // Get output parameter\n            int userCount = cstmt.getInt(1);\n            System.out.println(\"Total users: \" + userCount);\n            \n        } catch (SQLException e) {\n            System.err.println(\"Lỗi gọi stored procedure: \" + e.getMessage());\n        }\n    }\n}\n```\n\n## Best Practices\n\n### 1. Resource Management\n\n```java\n// Tốt - sử dụng try-with-resources\npublic User getUserById(Long id) throws SQLException {\n    String sql = \"SELECT * FROM users WHERE id = ?\";\n    \n    try (Connection conn = getConnection();\n         PreparedStatement pstmt = conn.prepareStatement(sql)) {\n        \n        pstmt.setLong(1, id);\n        \n        try (ResultSet rs = pstmt.executeQuery()) {\n            if (rs.next()) {\n                return mapResultSetToUser(rs);\n            }\n        }\n    }\n    return null;\n}\n\n// Tránh - không đóng resources\npublic User getUserByIdBad(Long id) throws SQLException {\n    Connection conn = getConnection();\n    PreparedStatement pstmt = conn.prepareStatement(\"SELECT * FROM users WHERE id = ?\");\n    pstmt.setLong(1, id);\n    ResultSet rs = pstmt.executeQuery();\n    // Quên đóng resources!\n    return null;\n}\n```\n\n### 2. PreparedStatement\n\n```java\n// Tốt - sử dụng PreparedStatement\npublic User getUserByEmail(String email) throws SQLException {\n    String sql = \"SELECT * FROM users WHERE email = ?\";\n    try (Connection conn = getConnection();\n         PreparedStatement pstmt = conn.prepareStatement(sql)) {\n        \n        pstmt.setString(1, email);\n        // ...\n    }\n}\n\n// Tránh - SQL Injection\npublic User getUserByEmailBad(String email) throws SQLException {\n    String sql = \"SELECT * FROM users WHERE email = '\" + email + \"'\";\n    // Có thể bị SQL Injection!\n}\n```\n\n### 3. Connection Pooling\n\n```java\n// Tốt - sử dụng connection pool\npublic class UserDAO {\n    private final DataSource dataSource;\n    \n    public UserDAO(DataSource dataSource) {\n        this.dataSource = dataSource;\n    }\n    \n    public User getUserById(Long id) throws SQLException {\n        try (Connection conn = dataSource.getConnection()) {\n            // ...\n        }\n    }\n}\n\n// Tránh - tạo connection mới mỗi lần\npublic User getUserByIdBad(Long id) throws SQLException {\n    Connection conn = DriverManager.getConnection(url, username, password);\n    // Tạo connection mới mỗi lần - không hiệu quả!\n}\n```\n\n## Kết luận\n\nJDBC cung cấp:\n\n1. **Database Connectivity**: Kết nối với nhiều loại database\n2. **CRUD Operations**: Create, Read, Update, Delete\n3. **Transaction Management**: ACID properties\n4. **Connection Pooling**: Quản lý connection hiệu quả\n5. **Batch Operations**: Xử lý nhiều operations cùng lúc\n6. **Stored Procedures**: Gọi stored procedures\n\n### Lợi ích chính:\n\n- **Database Independence**: Không phụ thuộc vào database cụ thể\n- **Performance**: Truy cập database nhanh\n- **Flexibility**: Linh hoạt trong việc thao tác database\n- **Standard API**: Chuẩn hóa cách làm việc với database\n\n### Best Practices:\n\n- Sử dụng **try-with-resources** để quản lý resources\n- Sử dụng **PreparedStatement** để tránh SQL Injection\n- Sử dụng **Connection Pooling** cho performance\n- **Proper exception handling**\n- **Transaction management** cho data consistency\n- **Batch operations** cho bulk data\n- **Connection testing** và monitoring\n\nHãy thực hành các ví dụ trên để nắm vững JDBC và database connectivity trong Java!",
  "excerpt": "Tìm hiểu Java Database Connectivity (JDBC) - từ kết nối database, CRUD operations đến transaction management và best practices.",
  "author": "TRAN NHAN",
  "category": "Java JDBC",
  "tags": ["Java", "JDBC", "Database", "SQL"],
  "featuredImageUrl": "https://images.unsplash.com/photo-1555066931-4365d14bab8c?w=400&h=250&fit=crop&crop=center",
  "isPublished": true,
  "createdDate": "2024-02-02T09:15:00Z",
  "updatedDate": "2024-02-02T09:15:00Z",
  "viewCount": 520
}